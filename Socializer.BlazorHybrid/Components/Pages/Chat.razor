@page "/chat/{ChatHash}"

@using Microsoft.AspNetCore.SignalR.Client
@using Socializer.BlazorHybrid.Extensions
@using Socializer.BlazorHybrid.ViewModels
@using Socializer.Client.ChatClient
@using Socializer.Shared
@using Socializer.Shared.Extensions

@inject IChatConnectionClient chatConnectionClient
@inject IJSRuntime js
@inject LayoutState layoutState
@inject StateContainer stateContainer

@implements IAsyncDisposable


<div class="d-flex flex-column vh-100">
    <h2 class="flex-shrink-0">
        @layoutState.Header
    </h2>

    <div id="chat-messages" @ref="chatMessagesRef" class="flex-grow-1 overflow-auto">
        @foreach (var message in chatViewModel.Messages)
        {
            <div class="d-flex @MessageAlignClass(message.Author) mb-2">
                <div class="@MessageStyleClass(message.Author) p-2 rounded-3" style="max-width: 95%;">
                    @message.Content.ToHtmlBreaks()
                </div>
            </div>
        }
    </div>

    <div class="flex-shrink-0 input-group m-1">
        <InputText class="form-control input-field m-1" @bind-Value="chatViewModel.NewMessage" @onfocus="@ScrollToBottomIfBottomAsync" title="Type message .." />
        <button class="btn btn-primary w-100 m-1" style="padding-bottom: env(safe-area-inset-bottom, 1rem);" @onclick="SendMessageAsync">Send</button>
    </div>
</div>

@code {
    [Parameter] public string ChatHash { get; set; }

    private EditContext editContext;
    private ElementReference chatMessagesRef;
    private ChatViewModel chatViewModel = new();

    protected override async Task OnInitializedAsync()
    {
        editContext = new EditContext(chatViewModel);
        layoutState.Header = $"Chat";

        // Init chat
        await chatConnectionClient.InitAsync(OnReceiveMessageAsync);
        await chatConnectionClient.JoinGroupAsync(ChatHash);

        await Task.Delay(100);
        await ScrollToBottomAsync();
    }

    private async Task OnReceiveMessageAsync(string author, string content)
    {
        chatViewModel.Messages.Add(new ChatMessage() { Author = author, Content = content });
        await InvokeAsync(StateHasChanged);
        await ScrollToBottomAsync();
    }

    private async Task SendMessageAsync()
    {
        if (string.IsNullOrWhiteSpace(chatViewModel.NewMessage))
            return;

        var result = await chatConnectionClient.SendMessageAsync(stateContainer.User.Id, ChatHash, chatViewModel.NewMessage);

        if (result.IsSuccess)
        {
            chatViewModel.NewMessage = string.Empty;
        }

        await ScrollToBottomAsync();
    }

    private string MessageStyleClass(string author)
    {
        return author switch
        {
            var a when 
                stateContainer.User.Username.Equals(a, StringComparison.InvariantCultureIgnoreCase) => "bg-info-subtle",
                "bot" => "bg-primary-subtle",
                "error" => "bg-danger-subtle",
                _ => "bg-secondary-subtle"
        };
    }

    private string MessageAlignClass(string author)
    {
        return stateContainer.User.Username.Equals(author, StringComparison.InvariantCultureIgnoreCase) ? "justify-content-start" : "justify-content-end";
    }

    public async ValueTask DisposeAsync()
    {
        await chatConnectionClient.DisposeAsync();
    }

    private async Task ScrollToBottomAsync()
    {
        await Task.Delay(200);
        await js.InvokeVoidAsync("scrollToBottom", chatMessagesRef);
    }

    private async Task ScrollToBottomIfBottomAsync()
    {
        if (await js.InvokeAsync<bool>("isScrollAtBottom", chatMessagesRef))
            await ScrollToBottomAsync();
    }
}